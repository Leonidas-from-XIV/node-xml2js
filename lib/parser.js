// Generated by CoffeeScript 2.7.0
(function() {
  "use strict";
  var bom, defaults, events, isEmpty, isValidKey, processItem, processors, ref, sax, setImmediate,
    hasProp = {}.hasOwnProperty,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  sax = require('sax');

  events = require('events');

  bom = require('./bom');

  processors = require('./processors');

  setImmediate = require('timers').setImmediate;

  defaults = require('./defaults').defaults;

  // Underscore has a nice function for this, but we try to go without dependencies
  isEmpty = function(thing) {
    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
  };

  isValidKey = function(key) {
    return key !== '__proto__' && key !== 'constructor' && key !== 'prototype';
  };

  processItem = function(processors, item, key) {
    var i, len, process;
    for (i = 0, len = processors.length; i < len; i++) {
      process = processors[i];
      item = process(item, key);
    }
    return item;
  };

  ref = exports.Parser = class Parser extends events {
    constructor(opts) {
      var key, ref1, value;
      super();
      this.processAsync = this.processAsync.bind(this);
      this.assignOrPush = this.assignOrPush.bind(this);
      this.reset = this.reset.bind(this);
      this.parseString = this.parseString.bind(this);
      this.parseStringPromise = this.parseStringPromise.bind(this);
      if (!(this instanceof exports.Parser)) {
        // if this was called without 'new', create an instance with new and return
        return new exports.Parser(opts);
      }
      // copy this versions default options
      this.options = {};
      ref1 = defaults["0.2"];
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        value = ref1[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        // overwrite them with the specified options, if any
        this.options[key] = value;
      }
      // define the key used for namespaces
      if (this.options.xmlns) {
        this.options.xmlnskey = this.options.attrkey + "ns";
      }
      if (this.options.normalizeTags) {
        if (!this.options.tagNameProcessors) {
          this.options.tagNameProcessors = [];
        }
        this.options.tagNameProcessors.unshift(processors.normalize);
      }
      this.reset();
    }

    processAsync() {
      var chunk, err;
      boundMethodCheck(this, ref);
      try {
        if (this.remaining.length <= this.options.chunkSize) {
          chunk = this.remaining;
          this.remaining = '';
          this.saxParser = this.saxParser.write(chunk);
          return this.saxParser.close();
        } else {
          chunk = this.remaining.substr(0, this.options.chunkSize);
          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
          this.saxParser = this.saxParser.write(chunk);
          return setImmediate(this.processAsync);
        }
      } catch (error1) {
        err = error1;
        if (!this.saxParser.errThrown) {
          this.saxParser.errThrown = true;
          return this.emit(err);
        }
      }
    }

    assignOrPush(obj, key, newValue) {
      boundMethodCheck(this, ref);
      if (!isValidKey(key)) {
        return;
      }
      if (!(key in obj)) {
        if (!this.options.explicitArray) {
          return obj[key] = newValue;
        } else {
          return obj[key] = [newValue];
        }
      } else {
        if (!(obj[key] instanceof Array)) {
          obj[key] = [obj[key]];
        }
        return obj[key].push(newValue);
      }
    }

    reset() {
      var attrkey, charkey, ontext, stack;
      boundMethodCheck(this, ref);
      // remove all previous listeners for events, to prevent event listener
      // accumulation
      this.removeAllListeners();
      // make the SAX parser. tried trim and normalize, but they are not
      // very helpful
      this.saxParser = sax.parser(this.options.strict, {
        trim: false,
        normalize: false,
        xmlns: this.options.xmlns
      });
      // emit one error event if the sax parser fails. this is mostly a hack, but
      // the sax parser isn't state of the art either.
      this.saxParser.errThrown = false;
      this.saxParser.onerror = (error) => {
        this.saxParser.resume();
        if (!this.saxParser.errThrown) {
          this.saxParser.errThrown = true;
          return this.emit("error", error);
        }
      };
      this.saxParser.onend = () => {
        if (!this.saxParser.ended) {
          this.saxParser.ended = true;
          return this.emit("end", this.resultObject);
        }
      };
      // another hack to avoid throwing exceptions when the parsing has ended
      // but the user-supplied callback throws an error
      this.saxParser.ended = false;
      // always use the '#' key, even if there are no subkeys
      // setting this property by and is deprecated, yet still supported.
      // better pass it as explicitCharkey option to the constructor
      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
      this.resultObject = null;
      stack = [];
      // aliases, so we don't have to type so much
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      this.saxParser.onopentag = (node) => {
        var key, newValue, obj, processedKey, ref1;
        obj = {};
        obj[charkey] = "";
        if (!this.options.ignoreAttrs) {
          ref1 = node.attributes;
          for (key in ref1) {
            if (!hasProp.call(ref1, key)) continue;
            if (!(attrkey in obj) && !this.options.mergeAttrs) {
              obj[attrkey] = {};
            }
            newValue = this.options.attrValueProcessors ? processItem(this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
            processedKey = this.options.attrNameProcessors ? processItem(this.options.attrNameProcessors, key) : key;
            if (isValidKey(processedKey)) {
              if (this.options.mergeAttrs) {
                this.assignOrPush(obj, processedKey, newValue);
              } else {
                obj[attrkey][processedKey] = newValue;
              }
            }
          }
        }
        // need a place to store the node name
        obj["#name"] = this.options.tagNameProcessors ? processItem(this.options.tagNameProcessors, node.name) : node.name;
        if (this.options.xmlns) {
          obj[this.options.xmlnskey] = {
            uri: node.uri,
            local: node.local
          };
        }
        return stack.push(obj);
      };
      this.saxParser.onclosetag = () => {
        var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
        obj = stack.pop();
        nodeName = obj["#name"];
        if (!this.options.explicitChildren || !this.options.preserveChildrenOrder) {
          delete obj["#name"];
        }
        if (obj.cdata === true) {
          cdata = obj.cdata;
          delete obj.cdata;
        }
        s = stack[stack.length - 1];
        // remove the '#' key altogether if it's blank
        if (obj[charkey].match(/^\s*$/) && !cdata) {
          emptyStr = obj[charkey];
          delete obj[charkey];
        } else {
          if (this.options.trim) {
            obj[charkey] = obj[charkey].trim();
          }
          if (this.options.normalize) {
            obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
          }
          obj[charkey] = this.options.valueProcessors ? processItem(this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
          // also do away with '#' key altogether, if there's no subkeys
          // unless EXPLICIT_CHARKEY is set
          if (Object.keys(obj).length === 1 && charkey in obj && !this.EXPLICIT_CHARKEY) {
            obj = obj[charkey];
          }
        }
        if (isEmpty(obj)) {
          if (typeof this.options.emptyTag === 'function') {
            obj = this.options.emptyTag();
          } else {
            obj = this.options.emptyTag !== '' ? this.options.emptyTag : emptyStr;
          }
        }
        if (this.options.validator != null) {
          xpath = "/" + ((function() {
            var i, len, results;
            results = [];
            for (i = 0, len = stack.length; i < len; i++) {
              node = stack[i];
              results.push(node["#name"]);
            }
            return results;
          })()).concat(nodeName).join("/");
          (() => {            // Wrap try/catch with an inner function to allow V8 to optimise the containing function
            // See https://github.com/Leonidas-from-XIV/node-xml2js/pull/369
            var err;
            try {
              return obj = this.options.validator(xpath, s && s[nodeName], obj);
            } catch (error1) {
              err = error1;
              return this.emit("error", err);
            }
          })();
        }
        // put children into <childkey> property and unfold chars if necessary
        if (this.options.explicitChildren && !this.options.mergeAttrs && typeof obj === 'object') {
          if (!this.options.preserveChildrenOrder) {
            node = {};
            // separate attributes
            if (this.options.attrkey in obj) {
              node[this.options.attrkey] = obj[this.options.attrkey];
              delete obj[this.options.attrkey];
            }
            // separate char data
            if (!this.options.charsAsChildren && this.options.charkey in obj) {
              node[this.options.charkey] = obj[this.options.charkey];
              delete obj[this.options.charkey];
            }
            if (Object.getOwnPropertyNames(obj).length > 0) {
              node[this.options.childkey] = obj;
            }
            obj = node;
          } else if (s) {
            // append current node onto parent's <childKey> array
            s[this.options.childkey] = s[this.options.childkey] || [];
            // push a clone so that the node in the children array can receive the #name property while the original obj can do without it
            objClone = {};
            for (key in obj) {
              if (!hasProp.call(obj, key)) continue;
              if (isValidKey(key)) {
                objClone[key] = obj[key];
              }
            }
            s[this.options.childkey].push(objClone);
            delete obj["#name"];
            // re-check whether we can collapse the node now to just the charkey value
            if (Object.keys(obj).length === 1 && charkey in obj && !this.EXPLICIT_CHARKEY) {
              obj = obj[charkey];
            }
          }
        }
        // check whether we closed all the open tags
        if (stack.length > 0) {
          return this.assignOrPush(s, nodeName, obj);
        } else {
          // if explicitRoot was specified, wrap stuff in the root tag name
          if (this.options.explicitRoot) {
            // avoid circular references
            old = obj;
            obj = {};
            obj[nodeName] = old;
          }
          this.resultObject = obj;
          // parsing has ended, mark that so we won't throw exceptions from
          // here anymore
          this.saxParser.ended = true;
          return this.emit("end", this.resultObject);
        }
      };
      ontext = (text) => {
        var charChild, s;
        s = stack[stack.length - 1];
        if (s) {
          s[charkey] += text;
          if (this.options.explicitChildren && this.options.preserveChildrenOrder && this.options.charsAsChildren && (this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
            s[this.options.childkey] = s[this.options.childkey] || [];
            charChild = {
              '#name': '__text__'
            };
            charChild[charkey] = text;
            if (this.options.normalize) {
              charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
            }
            s[this.options.childkey].push(charChild);
          }
          return s;
        }
      };
      this.saxParser.ontext = ontext;
      return this.saxParser.oncdata = (text) => {
        var s;
        s = ontext(text);
        if (s) {
          return s.cdata = true;
        }
      };
    }

    parseString(str, cb) {
      var err;
      boundMethodCheck(this, ref);
      if ((cb != null) && typeof cb === "function") {
        this.on("end", function(result) {
          this.reset();
          return cb(null, result);
        });
        this.on("error", function(err) {
          this.reset();
          return cb(err);
        });
      }
      try {
        str = str.toString();
        if (str.trim() === '') {
          this.emit("end", null);
          return true;
        }
        str = bom.stripBOM(str);
        if (this.options.async) {
          this.remaining = str;
          setImmediate(this.processAsync);
          return this.saxParser;
        }
        return this.saxParser.write(str).close();
      } catch (error1) {
        err = error1;
        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
          this.emit('error', err);
          return this.saxParser.errThrown = true;
        } else if (this.saxParser.ended) {
          throw err;
        }
      }
    }

    parseStringPromise(str) {
      boundMethodCheck(this, ref);
      return new Promise((resolve, reject) => {
        return this.parseString(str, (err, value) => {
          if (err) {
            return reject(err);
          } else {
            return resolve(value);
          }
        });
      });
    }

  };

  exports.parseString = function(str, a, b) {
    var cb, options, parser;
    // let's determine what we got as arguments
    if (b != null) {
      if (typeof b === 'function') {
        cb = b;
      }
      if (typeof a === 'object') {
        options = a;
      }
    } else {
      // well, b is not set, so a has to be a callback
      if (typeof a === 'function') {
        cb = a;
      }
      // and options should be empty - default
      options = {};
    }
    // the rest is super-easy
    parser = new exports.Parser(options);
    return parser.parseString(str, cb);
  };

  exports.parseStringPromise = function(str, a) {
    var options, parser;
    if (typeof a === 'object') {
      options = a;
    }
    parser = new exports.Parser(options);
    return parser.parseStringPromise(str);
  };

}).call(this);
