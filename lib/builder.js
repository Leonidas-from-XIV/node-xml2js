// Generated by CoffeeScript 2.7.0
(function() {
  "use strict";
  var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA,
    hasProp = {}.hasOwnProperty;

  builder = require('xmlbuilder');

  defaults = require('./defaults').defaults;

  requiresCDATA = function(entry) {
    return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
  };

  // Note that we do this manually instead of using xmlbuilder's `.dat` method
  // since it does not support escaping the CDATA close entity (throws an error if
  // it exists, and if it's pre-escaped).
  wrapCDATA = function(entry) {
    return `<![CDATA[${escapeCDATA(entry)}]]>`;
  };

  escapeCDATA = function(entry) {
    // Split the CDATA section in two;
    // The first contains the ']]'
    // The second contains the '>'
    // When later parsed, it will be put back together as ']]>'
    return entry.replace(']]>', ']]]]><![CDATA[>');
  };

  exports.Builder = class Builder {
    constructor(opts) {
      var key, ref, value;
      // copy this versions default options
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        // overwrite them with the specified options, if any
        this.options[key] = value;
      }
    }

    buildObject(rootObj) {
      var attrkey, charkey, render, rootElement, rootName;
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      // If there is a sane-looking first element to use as the root,
      // and the user hasn't specified a non-default rootName,
      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {
        // we'll take the first element as the root element
        rootName = Object.keys(rootObj)[0];
        rootObj = rootObj[rootName];
      } else {
        // otherwise we'll use whatever they've set, or the default
        rootName = this.options.rootName;
      }
      render = (element, obj) => {
        var attr, child, entry, index, key, value;
        if (typeof obj !== 'object') {
          // single element, just append it as text
          if (this.options.cdata && requiresCDATA(obj)) {
            element.raw(wrapCDATA(obj));
          } else {
            element.txt(obj);
          }
        } else if (Array.isArray(obj)) {
          for (index in obj) {
            if (!hasProp.call(obj, index)) continue;
            child = obj[index];
            for (key in child) {
              entry = child[key];
              element = render(element.ele(key), entry).up();
            }
          }
        } else {
          for (key in obj) {
            if (!hasProp.call(obj, key)) continue;
            child = obj[key];
            // Case #1 Attribute
            if (key === attrkey) {
              if (typeof child === "object") {
// Inserts tag attributes
                for (attr in child) {
                  value = child[attr];
                  element = element.att(attr, value);
                }
              }
            // Case #2 Char data (CDATA, etc.)
            } else if (key === charkey) {
              if (this.options.cdata && requiresCDATA(child)) {
                element = element.raw(wrapCDATA(child));
              } else {
                element = element.txt(child);
              }
            // Case #3 Array data
            } else if (Array.isArray(child)) {
              for (index in child) {
                if (!hasProp.call(child, index)) continue;
                entry = child[index];
                if (typeof entry === 'string') {
                  if (this.options.cdata && requiresCDATA(entry)) {
                    element = element.ele(key).raw(wrapCDATA(entry)).up();
                  } else {
                    element = element.ele(key, entry).up();
                  }
                } else {
                  element = render(element.ele(key), entry).up();
                }
              }
            // Case #4 Objects
            } else if (typeof child === "object") {
              element = render(element.ele(key), child).up();
            } else {
              // Case #5 String and remaining types
              if (typeof child === 'string' && this.options.cdata && requiresCDATA(child)) {
                element = element.ele(key).raw(wrapCDATA(child)).up();
              } else {
                if (child == null) {
                  child = '';
                }
                element = element.ele(key, child.toString()).up();
              }
            }
          }
        }
        return element;
      };
      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
        headless: this.options.headless,
        allowSurrogateChars: this.options.allowSurrogateChars
      });
      return render(rootElement, rootObj).end(this.options.renderOpts);
    }

  };

}).call(this);
