// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var CHILDREN_KEY, builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  builder = require('xmlbuilder');

  defaults = require('./defaults').defaults;

  CHILDREN_KEY = '$$children_da914993d9904559be754444a4685d08$$';

  requiresCDATA = function(entry) {
    return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
  };

  wrapCDATA = function(entry) {
    return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
  };

  escapeCDATA = function(entry) {
    return entry.replace(']]>', ']]]]><![CDATA[>');
  };

  exports.Builder = (function() {
    function Builder(opts) {
      this.preprocess = bind(this.preprocess, this);
      var key, ref, value;
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
    }

    Builder.prototype.buildObject = function(rootObj) {
      var attrkey, charkey, entry, i, key, len, obj, render, rootArray, rootElement, rootName;
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {
        rootName = Object.keys(rootObj)[0];
        rootObj = rootObj[rootName];
      } else {
        rootName = this.options.rootName;
      }
      render = (function(_this) {
        return function(element, obj) {
          var attr, child, childObj, i, key, len, value;
          if (typeof obj !== 'object') {
            if (_this.options.cdata && requiresCDATA(obj)) {
              element.raw(wrapCDATA(obj));
            } else {
              element.txt(obj);
            }
          } else {
            for (key in obj) {
              if (!hasProp.call(obj, key)) continue;
              child = obj[key];
              if (key === attrkey) {
                if (typeof child === "object") {
                  for (attr in child) {
                    value = child[attr];
                    element = element.att(attr, value);
                  }
                }
              } else if (key === charkey) {
                if (_this.options.cdata && requiresCDATA(child)) {
                  element = element.raw(wrapCDATA(child));
                } else {
                  element = element.txt(child);
                }
              } else if (key === CHILDREN_KEY) {
                for (i = 0, len = child.length; i < len; i++) {
                  childObj = child[i];
                  element = render(element.ele(childObj.name), childObj.node).up();
                }
              } else {
                throw new Error('Invalid object given to xml2js builder');
              }
            }
          }
          return element;
        };
      })(this);
      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
        headless: this.options.headless,
        allowSurrogateChars: this.options.allowSurrogateChars
      });
      if (Array.isArray(rootObj)) {
        rootArray = rootObj;
        rootObj = {};
        for (i = 0, len = rootArray.length; i < len; i++) {
          obj = rootArray[i];
          for (key in obj) {
            entry = obj[key];
            if (rootObj[key]) {
              rootObj[key].push(entry);
            } else {
              rootObj[key] = [entry];
            }
          }
        }
      }
      rootObj = this.preprocess(rootObj);
      return render(rootElement, rootObj).end(this.options.renderOpts);
    };

    Builder.prototype.preprocess = function(obj) {
      var child, children, i, key, len, ref, ref1, ref2, ref3, ret, sourcePosition, value;
      if (typeof obj !== 'object') {
        return obj || '';
      }
      if (Array.isArray(obj)) {
        return obj.map(this.preprocess);
      }
      ret = {};
      children = [];
      sourcePosition = 0;
      for (key in obj) {
        if (!hasProp.call(obj, key)) continue;
        value = obj[key];
        if (key === this.options.attrkey || key === this.options.charkey) {
          ret[key] = value;
        } else if (key === this.options.sourcemapkey) {
          continue;
        } else {
          if (Array.isArray(value)) {
            for (i = 0, len = value.length; i < len; i++) {
              child = value[i];
              sourcePosition = (child != null ? (ref = child.$source) != null ? (ref1 = ref.start) != null ? ref1.position : void 0 : void 0 : void 0) || (sourcePosition + 1);
              children.push({
                name: key,
                sourcePosition: sourcePosition,
                node: this.preprocess(child)
              });
            }
          } else if (typeof value === 'object') {
            sourcePosition = (value != null ? (ref2 = value.$source) != null ? (ref3 = ref2.start) != null ? ref3.position : void 0 : void 0 : void 0) || (sourcePosition + 1);
            children.push({
              name: key,
              sourcePosition: sourcePosition,
              node: this.preprocess(value)
            });
          } else {
            sourcePosition = sourcePosition + 1;
            children.push({
              name: key,
              sourcePosition: sourcePosition,
              node: value || ''
            });
          }
        }
      }
      if (children.length > 0) {
        children.sort(function(a, b) {
          return a.sourcePosition - b.sourcePosition;
        });
        ret[CHILDREN_KEY] = children;
      }
      return ret;
    };

    return Builder;

  })();

}).call(this);
